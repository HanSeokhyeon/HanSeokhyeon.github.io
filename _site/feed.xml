<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2019-11-01T14:15:07+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Han Seokhyeon</title><subtitle>A blog about technology and stuff related</subtitle><entry><title type="html">Pycharm SSH로 서버에서 run하기</title><link href="http://localhost:4000/pycharm-ssh-run/" rel="alternate" type="text/html" title="Pycharm SSH로 서버에서 run하기" /><published>2019-11-01T13:44:00+09:00</published><updated>2019-11-01T13:44:00+09:00</updated><id>http://localhost:4000/pycharm-ssh-run</id><content type="html" xml:base="http://localhost:4000/pycharm-ssh-run/">&lt;p&gt;지난 포스트에서 파이참에서 서버의 터미널을 여는 것 까지 성공했다. 하지만 진짜 파이참으로 이용해 딥러닝 개발을 하기 위해서는 run까지 해야한다. 그래서 공부해봤다.&lt;/p&gt;

&lt;h1 id=&quot;1-interpreter-설정&quot;&gt;1. Interpreter 설정&lt;/h1&gt;

&lt;p&gt;Files/Settings에 들어간다. 다시 Project: ***/Project Interpreter를 누르면 아래와 같은 화면을 볼 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/project_interpreter.png&quot; alt=&quot;project_interpreter&quot; /&gt;&lt;/p&gt;

&lt;p&gt;오른쪽 위에 톱니바퀴모양 설정 버튼을 누르고 추가적으로 add까지 누른다. 다시 SSH Interpreter를 누르면 아래와 같은 화면을 볼 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/ssh_interpreter.png&quot; alt=&quot;ssh_interpreter&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Host에는 서버의 IP주소, Username은 서버의 name을 입력한다. Port 번호를 변경했다면 바꾼 번호로 입력한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/ssh_interpreter2.png&quot; alt=&quot;ssh_interpreter2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Password를 사용한다면 password를, 공개키를 사용한다면 공개키 정보를 입력한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/ssh_interpreter3.png&quot; alt=&quot;ssh_interpreter3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;흠 머 finish.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/ssh_interpreter4.png&quot; alt=&quot;ssh_interpreter4&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이렇게 이제 새로운 ssh interpreter가 생겼다. 서버에 깔려있는 파이썬 패키지들이 눈에 들어온다.&lt;/p&gt;

&lt;p&gt;OK를 누르면 로컬에 있는 파이썬 프로젝트가 서버에 /tmp/pycharm_project로 전송된다. 전송이 완료되고 나서 평소 파이썬 코드를 돌리듯이 run하면 서버에서 코드가 돌아간다. 신난다!&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;출처:&lt;br /&gt;
&lt;a href=&quot;https://simonjisu.github.io/datascience/2018/06/24/pycharmssh.html&quot;&gt;https://simonjisu.github.io/datascience/2018/06/24/pycharmssh.html&lt;/a&gt;&lt;/p&gt;</content><author><name>HanSeokhyeon</name></author><category term="blog" /><summary type="html">지난 포스트에서 파이참에서 서버의 터미널을 여는 것 까지 성공했다. 하지만 진짜 파이참으로 이용해 딥러닝 개발을 하기 위해서는 run까지 해야한다. 그래서 공부해봤다.</summary></entry><entry><title type="html">Pycharm SSH Terminal 연결하기</title><link href="http://localhost:4000/pycharm-ssh-terminal/" rel="alternate" type="text/html" title="Pycharm SSH Terminal 연결하기" /><published>2019-11-01T11:31:00+09:00</published><updated>2019-11-01T11:31:00+09:00</updated><id>http://localhost:4000/pycharm-ssh-terminal</id><content type="html" xml:base="http://localhost:4000/pycharm-ssh-terminal/">&lt;p&gt;연구실의 데스크탑을 서버로 사용하고 개인 노트북을 로컬로 사용하려고 시도하고 있다. SSH server로 데스크탑 우분투로 접속하는 것을 성공했지만, 좀 더 편한 이용을 위해 PyCharm Professional에서 지원하는 SSH plugin을 사용해보고자 한다. 참고로 PyCharm Professional은 유료버전이나 학생인증을 하면 무료로 사용할 수 있다.&lt;/p&gt;

&lt;h1 id=&quot;1-ssh-server-접속-환경-구축&quot;&gt;1. SSH server 접속 환경 구축&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://hanseokhyeon.github.io/ssh-server/&quot;&gt;여기&lt;/a&gt;를 참고하길 바란다.&lt;/p&gt;

&lt;h1 id=&quot;2-pycharm-ssh-remote-run-plugin-설치&quot;&gt;2. Pycharm SSH Remote Run plugin 설치&lt;/h1&gt;

&lt;p&gt;SSH Remote Run은 bundle plugin이므로 기본적으로 설치 되어 있을 것이다.&lt;/p&gt;

&lt;p&gt;Settings/Plugins에 installed를 눌러서 설치가 되어 있는지 확인하자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/ssh_remote_run.png&quot; alt=&quot;ssh_remote_run&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;3-ssh-terminal-연결&quot;&gt;3. SSH terminal 연결&lt;/h1&gt;

&lt;p&gt;메인메뉴에 Tools/Start SSH Session을 누르면 정보를 입력하는 창이 뜬다. 평소에 터미널로 SSH server에 접속하듯이 호스트, 사용자, 포트번호, 비밀번호를 입력하면 터미널이 연결된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/ssh_session.png&quot; alt=&quot;ssh_session&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이와 같이 입력하면&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/terminal.png&quot; alt=&quot;terminal&quot; /&gt;&lt;/p&gt;

&lt;p&gt;연결된다. 다음에는 run을 서버에서 하는 방법을 연구할 계획이다.&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;출처:&lt;br /&gt;
&lt;a href=&quot;https://www.jetbrains.com/help/pycharm/running-ssh-terminal.html&quot;&gt;https://www.jetbrains.com/help/pycharm/running-ssh-terminal.html&lt;/a&gt;&lt;/p&gt;</content><author><name>HanSeokhyeon</name></author><category term="blog" /><summary type="html">연구실의 데스크탑을 서버로 사용하고 개인 노트북을 로컬로 사용하려고 시도하고 있다. SSH server로 데스크탑 우분투로 접속하는 것을 성공했지만, 좀 더 편한 이용을 위해 PyCharm Professional에서 지원하는 SSH plugin을 사용해보고자 한다. 참고로 PyCharm Professional은 유료버전이나 학생인증을 하면 무료로 사용할 수 있다.</summary></entry><entry><title type="html">gdb에서 fopen 함수 디버깅시 step을 사용했을 때 에러</title><link href="http://localhost:4000/gdb-step-error/" rel="alternate" type="text/html" title="gdb에서 fopen 함수 디버깅시 step을 사용했을 때 에러" /><published>2019-10-31T12:50:00+09:00</published><updated>2019-10-31T12:50:00+09:00</updated><id>http://localhost:4000/gdb-step-error</id><content type="html" xml:base="http://localhost:4000/gdb-step-error/">&lt;p&gt;gdb를 이용해 step 명령어를 사용해 디버깅시 fopen에서 파일을 찾을 수 없다며 에러가 나는 것을 확인하였다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Breakpoint 1, main () at main.c:24
24			file_sp.err_sp = fopen(&quot;out/han/SP/error.csv&quot;, &quot;wt&quot;); // save error of estimating secondary path 
(gdb) s
_IO_new_fopen (filename=0x555555556383 &quot;out/han/SP/error.csv&quot;, mode=0x555555556380 &quot;wt&quot;) at iofopen.c:88
88	iofopen.c: 그런 파일이나 디렉터리가 없습니다.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;찾아보니 step과 next 명령어의 차이점에서 나타나는 문제였는데 영어로는 설명이 이렇다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;“The step command follows the code into a function call. When stepping, gdb prints each source line before executing it. If you step into a library function, gdb wants to display the source, but those file are not available on the system. The complaint is expected and harmless. If you use the next command instead, it will step over and treat the entire call as a single step.”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;“step 명령어는 코드를 따라 함수 호출로 이어집니다. step 할 때 gdb는 각 소스 라인을 실행하기 전에 인쇄합니다. 라이브러리 함수로 들어가면 gdb가 소스를 표시하려고하지만 해당 파일을 시스템에서 사용할 수 없습니다. 다음 명령을 대신 사용하면 전체 호출이 한 단계 씩 처리됩니다.”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;머 이렇단다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Breakpoint 1, main () at main.c:24
24			file_sp.err_sp = fopen(&quot;out/han/SP/error.csv&quot;, &quot;wt&quot;); // save error of estimating secondary path 
(gdb) n
25			file_sp.f_white = fopen(&quot;data/han/SP/white_noise_11second_16k.raw&quot;, &quot;rb&quot;); // original
(gdb) 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;s 대신 n을 사용하니 정상적으로 작동한다.&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;출처:&lt;br /&gt;
&lt;a href=&quot;https://stackoverflow.com/questions/25564864/trouble-with-opening-file-for-read-with-fopen/25564973&quot;&gt;https://stackoverflow.com/questions/25564864/trouble-with-opening-file-for-read-with-fopen/25564973&lt;/a&gt;&lt;/p&gt;</content><author><name>HanSeokhyeon</name></author><category term="blog" /><summary type="html">gdb를 이용해 step 명령어를 사용해 디버깅시 fopen에서 파일을 찾을 수 없다며 에러가 나는 것을 확인하였다.</summary></entry><entry><title type="html">gdb 사용해서 C 디버깅하기</title><link href="http://localhost:4000/gdb-tutorial/" rel="alternate" type="text/html" title="gdb 사용해서 C 디버깅하기" /><published>2019-10-31T00:32:00+09:00</published><updated>2019-10-31T00:32:00+09:00</updated><id>http://localhost:4000/gdb-tutorial</id><content type="html" xml:base="http://localhost:4000/gdb-tutorial/">&lt;p&gt;C를 개발하는데 디버깅 안할 수는 없다. 
vim을 이용해 gcc로 C 개발을 시작했고, 드디어 디버깅이 필요한 시점이 왔다.&lt;/p&gt;

&lt;h1 id=&quot;1-디버깅-시작&quot;&gt;1. 디버깅 시작&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;gdb ./main
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;실행파일을 gdb로 연다.&lt;/p&gt;

&lt;p&gt;output:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;GNU gdb (Ubuntu 8.1-0ubuntu3.1) 8.1.0.20180409-git
Copyright (C) 2018 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later &amp;lt;http://gnu.org/licenses/gpl.html&amp;gt;
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type &quot;show copying&quot;
and &quot;show warranty&quot; for details.
This GDB was configured as &quot;x86_64-linux-gnu&quot;.
Type &quot;show configuration&quot; for configuration details.
For bug reporting instructions, please see:
&amp;lt;http://www.gnu.org/software/gdb/bugs/&amp;gt;.
Find the GDB manual and other documentation resources online at:
&amp;lt;http://www.gnu.org/software/gdb/documentation/&amp;gt;.
For help, type &quot;help&quot;.
Type &quot;apropos word&quot; to search for commands related to &quot;word&quot;...
Reading symbols from ./main...done.
(gdb)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;2-list-명령어&quot;&gt;2. list 명령어&lt;/h1&gt;
&lt;p&gt;list 명령어는 현재 위치로부터 10줄의 코드를 출력한다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(gdb) list
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;output:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;2	#include &amp;lt;stdio.h&amp;gt;
3	#include &amp;lt;stdlib.h&amp;gt;
4	#include &amp;lt;math.h&amp;gt;
5	#include &amp;lt;string.h&amp;gt;
6	
7	#include &quot;common.h&quot;
8	#include &quot;synchronizer.h&quot;
9	#include &quot;secondary_path.h&quot;
10	#include &quot;anc.h&quot;
11	#include &quot;functional.h&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;참고로 list 명령어를 입력할 때마다 현재 위치가 이동한다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(gdb) list
12	
13	//function
14	
15	int main()
16	{
17	
18		float *secondary_path, *anc_filter;
19		
20		if (SECONDARY_PATH) {
21			////////////////////Estimate secondary path////////////////////
(gdb) list
22	
23			struct FILE_SP file_sp;
24			file_sp.err_sp = fopen(&quot;out/han/SP/error.csv&quot;, &quot;wt&quot;); // save error of estimating secondary path 
25			file_sp.f_white = fopen(&quot;data/han/SP/white_noise_11second_16k.raw&quot;, &quot;rb&quot;); // original
26			file_sp.f_reals = fopen(&quot;data/han/SP/white_16k_100.raw&quot;, &quot;rb&quot;); // recorded by FB mic
27	
28			if (USE_S_HAN){
29				char sp_name[100] = &quot;data/han/filter_tab/lpf64.csv&quot;;
30				filter_init_file(secondary_path, FILTER_TAB_SP, sp_name);
31			}
(gdb)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;3-break-명령어&quot;&gt;3. break 명령어&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(gdb) b 28
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;output:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Breakpoint 1 at 0xd92: file main.c, line 28.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위와 같이 입력하면 break가 설정된다.&lt;/p&gt;

&lt;h1 id=&quot;4-run-명령어&quot;&gt;4. run 명령어&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(gdb) r
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;output:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Starting program: /home/hanseokhyeon/CProjects/filtered-X/main 

Breakpoint 1, main () at main.c:29
29				char sp_name[100] = &quot;data/han/filter_tab/lpf64.csv&quot;;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;r을 입력하면 break point까지 프로그램이 실행된다.&lt;/p&gt;

&lt;h1 id=&quot;5-step-명령어&quot;&gt;5. step 명령어&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(gdb) s
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;output:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;30				filter_init_file(secondary_path, FILTER_TAB_SP, sp_name);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;s를 입력하면 한 줄을 실행한다.&lt;/p&gt;

&lt;h1 id=&quot;6-print-명령어&quot;&gt;6. print 명령어&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(gdb) p sp_name
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;output:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$1 = &quot;data/han/filter_tab/lpf64.csv&quot;, '\000' &amp;lt;repeats 70 times&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;p와 변수명을 입력하면 변수를 출력한다.&lt;/p&gt;

&lt;h1 id=&quot;7-next-명령어&quot;&gt;7. next 명령어&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(gdb) n
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;output:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Program received signal SIGSEGV, Segmentation fault.
0x00007ffff76b577d in _IO_vfscanf_internal (s=s@entry=0x5555557598f0, format=&amp;lt;optimized out&amp;gt;, 
    argptr=argptr@entry=0x7fffffffd450, errp=errp@entry=0x0) at vfscanf.c:2447
2447	vfscanf.c: 그런 파일이나 디렉터리가 없습니다.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;n을 입력하면 다음 행을 실행한다. 그러면서 에러 발생 지점을 발견하였다. 파일이 없다한다.&lt;/p&gt;

&lt;h1 id=&quot;8-step-명령어&quot;&gt;8. step 명령어&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(gdb) s
30				filter_init_file(secondary_path, FILTER_TAB_SP, sp_name);
(gdb) s
filter_init_file (filter=0x200000, size=64, filename=0x7fffffffdc30 &quot;data/han/filter_tab/lpf64.csv&quot;) at functional.c:38
38		FILE* filter_file = fopen(filename, &quot;rt&quot;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;s를 입력하면 다음 행을 실행하며, 함수가 있다면 함수 내부까지 접근한다.&lt;/p&gt;

&lt;h1 id=&quot;9-quit-명령어&quot;&gt;9. quit 명령어&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(gdb) quit
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;종료다.&lt;/p&gt;

&lt;h1 id=&quot;10-display-명령어&quot;&gt;10. display 명령어&lt;/h1&gt;
&lt;p&gt;차차 공부해보자.&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;출처:&lt;br /&gt;
&lt;a href=&quot;https://jangpd007.tistory.com/54&quot;&gt;https://jangpd007.tistory.com/54&lt;/a&gt;&lt;/p&gt;</content><author><name>HanSeokhyeon</name></author><category term="blog" /><summary type="html">C를 개발하는데 디버깅 안할 수는 없다. vim을 이용해 gcc로 C 개발을 시작했고, 드디어 디버깅이 필요한 시점이 왔다.</summary></entry><entry><title type="html">Python과 Scipy 이용해서 FIR filter 만들기</title><link href="http://localhost:4000/python-fir-filter/" rel="alternate" type="text/html" title="Python과 Scipy 이용해서 FIR filter 만들기" /><published>2019-10-31T00:16:00+09:00</published><updated>2019-10-31T00:16:00+09:00</updated><id>http://localhost:4000/python-fir-filter</id><content type="html" xml:base="http://localhost:4000/python-fir-filter/">&lt;p&gt;Filtered-X LMS 알고리즘을 검증하는 과정에서 추정한 secondary path 대신 내가 임의로 만든 FIR filter를 넣으려고 한다. 그래서 FIR filter를 구현해야할 필요가 있었고 python과 scipy를 이용해 구현하였다. 사실 코드는 전부 참고하고 스펙만 변경하였다.&lt;/p&gt;

&lt;h1 id=&quot;1-함수-선언&quot;&gt;1. 함수 선언&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from pylab import *
import scipy.signal as signal

#Plot frequency and phase response
def mfreqz(b,a=1):
    w,h = signal.freqz(b,a)
    h_dB = 20 * log10 (abs(h))
    subplot(211)
    plot(w/max(w),h_dB)
    ylim(-150, 5)
    ylabel('Magnitude (db)')
    xlabel(r'Normalized Frequency (x$\pi$rad/sample)')
    title(r'Frequency response')
    subplot(212)
    h_Phase = unwrap(arctan2(imag(h),real(h)))
    plot(w/max(w),h_Phase)
    ylabel('Phase (radians)')
    xlabel(r'Normalized Frequency (x$\pi$rad/sample)')
    title(r'Phase response')
    subplots_adjust(hspace=0.5)

#Plot step and impulse response
def impz(b,a=1):
    l = len(b)
    impulse = repeat(0.,l); impulse[0] =1.
    x = arange(0,l)
    response = signal.lfilter(b,a,impulse)
    subplot(211)
    stem(x, response)
    ylabel('Amplitude')
    xlabel(r'n (samples)')
    title(r'Impulse response')
    subplot(212)
    step = cumsum(response)
    stem(x, step)
    ylabel('Amplitude')
    xlabel(r'n (samples)')
    title(r'Step response')
    subplots_adjust(hspace=0.5)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;생성된 FIR filter의 frequency, phase, impulse, step response를 plot하는 함수이다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;n = 64
a = signal.firwin(n, cutoff = 0.3, window = &quot;hamming&quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;scipy.signal.firwin 함수를 통해 FIR filter를 생성하였다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#Frequency and phase response
mfreqz(a)
show()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;output:&lt;br /&gt;
&lt;img src=&quot;/assets/images/lpf_spec2.png&quot; alt=&quot;lpf_spec2&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;impz(a)
show()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;output:&lt;br /&gt;
&lt;img src=&quot;/assets/images/lpf_spec.png&quot; alt=&quot;lpf_spec&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그림과 같이 LPF가 잘 생성되었다.&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;출처:&lt;br /&gt;
&lt;a href=&quot;http://mpastell.com/pweave/_downloads/FIR_design_rst.html&quot;&gt;http://mpastell.com/pweave/_downloads/FIR_design_rst.html&lt;/a&gt;&lt;/p&gt;</content><author><name>HanSeokhyeon</name></author><category term="blog" /><summary type="html">Filtered-X LMS 알고리즘을 검증하는 과정에서 추정한 secondary path 대신 내가 임의로 만든 FIR filter를 넣으려고 한다. 그래서 FIR filter를 구현해야할 필요가 있었고 python과 scipy를 이용해 구현하였다. 사실 코드는 전부 참고하고 스펙만 변경하였다.</summary></entry><entry><title type="html">리눅스 명령어 cd, ls, mkdir, cp, rm, mv</title><link href="http://localhost:4000/linux-command/" rel="alternate" type="text/html" title="리눅스 명령어 cd, ls, mkdir, cp, rm, mv" /><published>2019-10-30T16:12:00+09:00</published><updated>2019-10-30T16:12:00+09:00</updated><id>http://localhost:4000/linux-command</id><content type="html" xml:base="http://localhost:4000/linux-command/">&lt;p&gt;리눅스를 쓰다보면 명령어 공부가 자동으로 된다.&lt;/p&gt;

&lt;h1 id=&quot;1-현재-위치에-있는-파일과-디렉토리-출력-ls&quot;&gt;1. 현재 위치에 있는 파일과 디렉토리 출력 ls&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;~$ ls
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;output:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ANC                                        idea-IU-191.6707.61
Android                                    myblog
AndroidStudioProjects                      naver
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;와 같이 리스트가 출력된다. 이후 가고 싶은 곳으로 이동하자.&lt;/p&gt;

&lt;h1 id=&quot;2-현재-위치-이동-cd&quot;&gt;2. 현재 위치 이동 cd&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cd [가고자 하는 디렉토리]
~$ cd ANC
~/ANC$
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;위와 같이 현재 위치가 이동된다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;~/ANC$ cd ..
~$
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;..은 상위 디렉토리를 의미한다.&lt;/p&gt;

&lt;h1 id=&quot;3-디렉토리-생성-mkdir&quot;&gt;3. 디렉토리 생성 mkdir&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mkdir [디렉토리 이름]
mkdir filtered-X
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;이렇게 하면 디렉토리가 생성된다.&lt;/p&gt;

&lt;h1 id=&quot;4-파일-디렉토리-복사-cp&quot;&gt;4. 파일, 디렉토리 복사 cp&lt;/h1&gt;
&lt;p&gt;단순하게&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cp [원래 위치의 파일] [옮길 위치]
cp ~/ANC/v2.3.0_16k/main.c ~/CProjects/filtered-X
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;로 하면 원래 위치의 파일이 옮길 위치로 복사된다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cp [원래 위치/*] [옮길 위치]
cp ~/ANC/v2.3.0_16k/* ~/CProjects/filtered-X
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;원래 위치의 모든 파일이 옮길 위치로 복사된다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cp -r [원래 위치] [옮길 위치]
cp -r ~/ANC/v2.3.0_16k ~/CProjects/filtered-X
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;원래 위치 디렉토리가 옮길 위치로 이동된다.&lt;/p&gt;

&lt;h1 id=&quot;5-파일-디렉토리-제거&quot;&gt;5. 파일, 디렉토리 제거&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;rm [파일 이름]
rm main.c
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;파일 삭제&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;rm -f main.c
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;파일 강제 삭제&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;rm -r filtered-X
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;디렉토리 삭제&lt;/p&gt;

&lt;h1 id=&quot;6-파일-디렉토리-이름-변경&quot;&gt;6. 파일, 디렉토리 이름 변경&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mv [변경전 이름] [변경할 이름]
mv filtered-X filtered-X_no_secondary_path
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;이렇게 하면 디렉토리의 이름이 변경된다. 사실 mv는 파일이나 디렉토리를 이동시키는 명령어다. 여기서 나는 파일, 디렉토리 이름 변경이 이동으로 이뤄진다는 걸 깨달았다.&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;출처:&lt;br /&gt;
&lt;a href=&quot;https://webisfree.com/2018-02-05/%EB%A6%AC%EB%88%85%EC%8A%A4%EC%97%90%EC%84%9C-%ED%8C%8C%EC%9D%BC-%ED%8F%B4%EB%8D%94-%EC%9D%B4%EB%A6%84-%EB%B0%94%EA%BE%B8%EB%8A%94-%EB%B0%A9%EB%B2%95&quot;&gt;https://webisfree.com/2018-02-05/%EB%A6%AC%EB%88%85%EC%8A%A4%EC%97%90%EC%84%9C-%ED%8C%8C%EC%9D%BC-%ED%8F%B4%EB%8D%94-%EC%9D%B4%EB%A6%84-%EB%B0%94%EA%BE%B8%EB%8A%94-%EB%B0%A9%EB%B2%95&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://www.manualfactory.net/10805&quot;&gt;https://www.manualfactory.net/10805&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://webdir.tistory.com/140&quot;&gt;https://webdir.tistory.com/140&lt;/a&gt;&lt;/p&gt;</content><author><name>HanSeokhyeon</name></author><category term="blog" /><summary type="html">리눅스를 쓰다보면 명령어 공부가 자동으로 된다.</summary></entry><entry><title type="html">gcc 모듈 c 파일 이용해 컴파일하기</title><link href="http://localhost:4000/gcc-module/" rel="alternate" type="text/html" title="gcc 모듈 c 파일 이용해 컴파일하기" /><published>2019-10-30T12:47:00+09:00</published><updated>2019-10-30T12:47:00+09:00</updated><id>http://localhost:4000/gcc-module</id><content type="html" xml:base="http://localhost:4000/gcc-module/">&lt;p&gt;당연히 c 개발을 하면 c파일과 header파일로 파일을 분할해서 관리한다. 그래서 main.c와 모듈이 되는 c파일을 같이 컴파일하는 방법에 대해 알아보았다.&lt;/p&gt;

&lt;h1 id=&quot;1-file-준비&quot;&gt;1. file 준비&lt;/h1&gt;
&lt;p&gt;현 나의 상황으로는&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;main.c&lt;/li&gt;
  &lt;li&gt;anc.c, anc.h&lt;/li&gt;
  &lt;li&gt;functional.c, functional.h&lt;/li&gt;
  &lt;li&gt;secondary_path.c, secondary_path.h&lt;/li&gt;
  &lt;li&gt;synchronizer.c, synchronizer.h&lt;/li&gt;
  &lt;li&gt;common.h&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;로 프로젝트가 이루어져 있다.&lt;br /&gt;
모두 같은 디렉토리에 존재한다. header file들은 현재 디렉토리에 꼭 존재해야 한다.&lt;/p&gt;

&lt;p&gt;Visual studio에서는 common.h에서 stdlib.h 등 필수 헤더파일들을 include했지만 리눅스에서 gcc를 이용해 컴파일할 때는 common.h의 #include를 인식하지 못해 각 c 파일마다 수정해주었다.&lt;/p&gt;

&lt;p&gt;가장 먼저 무식하게 main object를 만들어보았다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;gcc -o main main.c
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;output:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;main.c: In function ‘main’:
main.c:44:2: warning: implicit declaration of function ‘fcloseall’; did you mean ‘fclose’? [-Wimplicit-function-declaration]
  fcloseall();
  ^~~~~~~~~
  fclose
/tmp/ccORf9Gr.o: In function `main':
main.c:(.text+0x7d): undefined reference to `Synchronizer'
main.c:(.text+0x91): undefined reference to `estimate_secondary_path'
main.c:(.text+0xbd): undefined reference to `save_filter'
main.c:(.text+0x361): undefined reference to `check_file_length'
main.c:(.text+0x3da): undefined reference to `cancel_noise'
collect2: error: ld returned 1 exit status
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;당연히 모듈에 존재하는 함수들이 define 되지 않았다고 에러를 출력하였다. 또한 fcloseall();에 대해 warning을 출력하기에 구글링해보니 &lt;code class=&quot;highlighter-rouge&quot;&gt;#define _GNU_SOURCE&lt;/code&gt;를 삽입해주면 된다해서 수정하였더니 정말 사라졌다.&lt;/p&gt;

&lt;p&gt;이제 제대로 된 명령어를 입력하였다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;gcc -o main -g main.c synchronizer.c anc.c functional.c secondary_path.c
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;-o는 object 파일의 이름을 넣어주는 옵션이고 -g는 컴파일 후 링크까지 해 실행파일을 만드는 옵션이다.&lt;/p&gt;

&lt;p&gt;output:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/tmp/ccKfl5g7.o: In function `cancel_noise':
/home/hanseokhyeon/ANC/v2.3.0_16k/anc.c:49: undefined reference to `floor'
/home/hanseokhyeon/ANC/v2.3.0_16k/anc.c:86: undefined reference to `pow'
/home/hanseokhyeon/ANC/v2.3.0_16k/anc.c:109: undefined reference to `floor'
/home/hanseokhyeon/ANC/v2.3.0_16k/anc.c:110: undefined reference to `floor'
/tmp/cckOEKHk.o: In function `gaussianRandom':
/home/hanseokhyeon/ANC/v2.3.0_16k/functional.c:52: undefined reference to `log'
/home/hanseokhyeon/ANC/v2.3.0_16k/functional.c:52: undefined reference to `sqrt'
collect2: error: ld returned 1 exit status
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;그러나 floor, pow, log, sqrt 함수가 define 되지 않았다고 에러를 출력하였다. 그렇다. 모두 math.h의 함수들이다. 그래서 구글링해보니 -lm이라는 옵션에 대한 정보를 찾아볼 수 있었다. -lm은 수학 라이브러리 옵션으로 수학 라이브러리를 include해준다.&lt;/p&gt;

&lt;p&gt;다시 제대로&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;gcc -o main -g main.c synchronizer.c anc.c functional.c secondary_path.c -lm

or

gcc -o main -g *.c -lm
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;하니 머 warning이 이것저것 뜨나 별거아니므로 무시했다. 여튼 실행파일이 만들어졌다.&lt;/p&gt;

&lt;p&gt;이제 실행해보자&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;./main
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;output:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Secondary path processing : 32000
processing : 32000ite   white
processing : 32000ite   white
processing : 32000ite   white
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;정상적으로 작동하였다. (숫자 뒤에 ite는 쓴적 없는거 같은데…) 역시나 다른 코드들과 마찬가지로 같은 코드를 돌렸을 때 속도가 눈에 띌 정도로 리눅스가 빨랐다. 이래서 쓰는건가. 아직 vim으로 편집하는 것이 어색하나 그래도 실제 많은 개발자들이 간단하게 vim을 이용해서 프로그래밍을 하는 경우가 종종 있기때문에 나도 연습해야겠다. 또한 gdb?를 이용해 디버깅하는 방법에 대해서도 알아봐야겠다.&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;출처:&lt;br /&gt;
&lt;a href=&quot;https://thrillfighter.tistory.com/101&quot;&gt;https://thrillfighter.tistory.com/101&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://askubuntu.com/questions/332884/how-to-compile-a-c-program-that-uses-math-h&quot;&gt;https://askubuntu.com/questions/332884/how-to-compile-a-c-program-that-uses-math-h&lt;/a&gt;&lt;/p&gt;</content><author><name>HanSeokhyeon</name></author><category term="blog" /><summary type="html">당연히 c 개발을 하면 c파일과 header파일로 파일을 분할해서 관리한다. 그래서 main.c와 모듈이 되는 c파일을 같이 컴파일하는 방법에 대해 알아보았다.</summary></entry><entry><title type="html">gcc 설치 및 사용법</title><link href="http://localhost:4000/gcc-tutorial/" rel="alternate" type="text/html" title="gcc 설치 및 사용법" /><published>2019-10-29T16:37:17+09:00</published><updated>2019-10-29T16:37:17+09:00</updated><id>http://localhost:4000/gcc-tutorial</id><content type="html" xml:base="http://localhost:4000/gcc-tutorial/">&lt;p&gt;리눅스에서 C언어 개발 환경을 구축하기 위해 gcc를 사용해본다.&lt;/p&gt;

&lt;h1 id=&quot;1-설치&quot;&gt;1. 설치&lt;/h1&gt;

&lt;p&gt;보통 우분투를 설치하면 gcc는 설치되어있다.
아래의 명령어를 통해 설치여부를 확인해보자.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;gcc
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;output:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;gcc: fatal error: no input files
compilation terminated.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이렇게 나오면 설치되어 있는 것이다.
버젼을 확인해보자.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;gcc --version
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;output:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;gcc (Ubuntu 7.4.0-1ubuntu1~18.04.1) 7.4.0
Copyright (C) 2017 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;이러하다.&lt;/p&gt;

&lt;p&gt;만약 설치가 안되어 있다면&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo apt-get install gcc
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;를 통해 설치하자.&lt;/p&gt;

&lt;h1 id=&quot;2-testc&quot;&gt;2. test.c&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;vim test.c
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;를 터미널에 쳐서 test.c 파일을 만들 준비를 하자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/testc.png&quot; alt=&quot;testc&quot; /&gt;&lt;/p&gt;

&lt;p&gt;vim 단축키를 잠시 설명하자면 a는 입력모드, ESC는 모드 나가기, x는 지우기, :wq는 저장후 종료다.&lt;/p&gt;

&lt;p&gt;:wq를 했으면 아마 home에 test.c가 생겼을 것이다. 
ls 명령어로 각자 확인하자.
이제 gcc 컴파일러를 통해 object 파일을 생성해보자.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;gcc -o test test.c
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;생성한 후 ls 명령어로 test라는 object 파일이 생성된 것을 확인해보자.
생성이 되었다면 파일을 실행해보자.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;./test
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;output:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;hello world
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;잘 실행된다.&lt;br /&gt;
Visual studio라는 강력한 IDE를 사용하다보니 vim로 C code를 개발하기는 매우 불편할 수 있다. 하지만 많은 IT회사가 C를 리눅스 기반으로 개발하니 피해갈 수 없는 도전이라고 생각한다.&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;출처:
&lt;a href=&quot;https://byd0105.tistory.com/9&quot;&gt;https://byd0105.tistory.com/9&lt;/a&gt;&lt;/p&gt;</content><author><name>HanSeokhyeon</name></author><category term="blog" /><summary type="html">리눅스에서 C언어 개발 환경을 구축하기 위해 gcc를 사용해본다.</summary></entry><entry><title type="html">tmux 사용법</title><link href="http://localhost:4000/tmux-tutorial/" rel="alternate" type="text/html" title="tmux 사용법" /><published>2019-10-22T04:30:17+09:00</published><updated>2019-10-22T04:30:17+09:00</updated><id>http://localhost:4000/tmux-tutorial</id><content type="html" xml:base="http://localhost:4000/tmux-tutorial/">&lt;p&gt;ssh server를 이용할 때 로컬에서 터미널을 끄면 서버와의 연결이 끊기며 서버에 프로그램이 종료되는 것이 불편하다. 
하지만 tmux를 이용하면 터미널을 꺼도 연결이 끊어지지 않으며 프로그램이 서버에서 계속 작동한다. 
그래서 tmux를 사용하고 사용법을 알아보고자 한다.&lt;/p&gt;

&lt;h1 id=&quot;1-설치&quot;&gt;1. 설치&lt;/h1&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo apt install tmux
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;매우 간단.&lt;/p&gt;

&lt;h1 id=&quot;2-실행&quot;&gt;2. 실행&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;tmux
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;매우 간단.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/tmux.png&quot; alt=&quot;tmux&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;3-ssh-server-접속&quot;&gt;3. ssh server 접속&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ssh han@123.123.12.12
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;output:&lt;br /&gt;
&lt;img src=&quot;/assets/images/ssh_server.png&quot; alt=&quot;ssh_server&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;4-run&quot;&gt;4. Run&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/run_ssh.png&quot; alt=&quot;run_ssh&quot; /&gt;&lt;/p&gt;

&lt;p&gt;터졌지만 중요한게 아니기에…&lt;/p&gt;

&lt;h1 id=&quot;5-log-off&quot;&gt;5. Log-off&lt;/h1&gt;

&lt;p&gt;Ctrl + b 누른 후 d를 누르면 log-off 된다. 터미널이 꺼진 것처럼 보이지만 사실 꺼진 것이 아니다.&lt;/p&gt;

&lt;p&gt;output:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[detached (from session 0)]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/log-off.png&quot; alt=&quot;log-off&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;6-attach&quot;&gt;6. Attach&lt;/h1&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;tmux attach
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;를 입력하면 다시 터미널로 돌아가게 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/attach.png&quot; alt=&quot;attach&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;출처:&lt;br /&gt;
&lt;a href=&quot;https://dgkim5360.tistory.com/entry/the-first-steps-for-tmux-terminal-multiplexer&quot;&gt;https://dgkim5360.tistory.com/entry/the-first-steps-for-tmux-terminal-multiplexer&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://m.blog.naver.com/kimmingul/221339305735&quot;&gt;https://m.blog.naver.com/kimmingul/221339305735&lt;/a&gt;&lt;/p&gt;</content><author><name>HanSeokhyeon</name></author><category term="blog" /><summary type="html">ssh server를 이용할 때 로컬에서 터미널을 끄면 서버와의 연결이 끊기며 서버에 프로그램이 종료되는 것이 불편하다. 하지만 tmux를 이용하면 터미널을 꺼도 연결이 끊어지지 않으며 프로그램이 서버에서 계속 작동한다. 그래서 tmux를 사용하고 사용법을 알아보고자 한다.</summary></entry><entry><title type="html">Ubuntu ssh 서버 구축하기</title><link href="http://localhost:4000/ssh-server/" rel="alternate" type="text/html" title="Ubuntu ssh 서버 구축하기" /><published>2019-10-22T03:30:17+09:00</published><updated>2019-10-22T03:30:17+09:00</updated><id>http://localhost:4000/ssh-server</id><content type="html" xml:base="http://localhost:4000/ssh-server/">&lt;p&gt;연구실 서버 컴퓨터에서 docker를 이용해야 할 상황이 생겼다. 그래서 ssh를 이용해 로컬에서 서버로 접속해 docker를 사용하기 위해 ssh 서버 사용하는 법을 공부했고 정리한다.&lt;/p&gt;

&lt;h1 id=&quot;1-ssh-설치&quot;&gt;1. ssh 설치&lt;/h1&gt;

&lt;p&gt;ubuntu에 로컬로 사용하기 위한 클라이언트 프로그램은 존재하지만 openssh-server는 없다. 그래서 설치가 필요하다. 업데이트 후 설치한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo apt-get update
sudo apt-get install openssh-server
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;2-ssh-서버-서비스-시작&quot;&gt;2. ssh 서버 서비스 시작&lt;/h1&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo service ssh start
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;서버를 실행한 후&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;service ssh status
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;로 상태확인을 해보자.&lt;br /&gt;
output:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;● ssh.service - OpenBSD Secure Shell server
   Loaded: loaded (/lib/systemd/system/ssh.service; enabled; vendor preset: enab
   Active: active (running) since Tue 2019-10-22 14:39:25 KST; 27min ago
 Main PID: 4635 (sshd)
    Tasks: 1 (limit: 4915)
   CGroup: /system.slice/ssh.service
           └─4635 /usr/sbin/sshd -D

10월 22 14:39:25 han-desktop systemd[1]: Starting OpenBSD Secure Shell server...
10월 22 14:39:25 han-desktop sshd[4635]: Server listening on 0.0.0.0 port 22.
10월 22 14:39:25 han-desktop sshd[4635]: Server listening on :: port 22.
10월 22 14:39:25 han-desktop systemd[1]: Started OpenBSD Secure Shell server.
10월 22 14:39:57 han-desktop sshd[5419]: Did not receive identification string f
10월 22 14:59:13 han-desktop sshd[5472]: Did not receive identification string f
10월 22 14:59:14 han-desktop sshd[5473]: pam_unix(sshd:auth): authentication fai
10월 22 14:59:16 han-desktop sshd[5473]: Failed password for root from 185.197.7
10월 22 14:59:18 han-desktop sshd[5473]: Connection closed by authenticating use
lines 1-17/17 (END)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ps -ef | grep sshd
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;로 실행중인 ssh 서버의 프로세스를 확인할 수 있다.&lt;br /&gt;
output:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root      4635     1  0 14:39 ?        00:00:00 /usr/sbin/sshd -D
han       5631  3459  0 15:08 pts/0    00:00:00 grep --color=auto sshd
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo netstat -ntlp | grep sshd
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;로 ip주소와 port 번호를 확인할 수 없다.&lt;br /&gt;
output:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      4635/sshd           
tcp6       0      0 :::22                   :::*                    LISTEN      4635/sshd
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;netstat가 없는 경우는&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo apt install net-tools
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;로 설치 후 다시 확인.&lt;/p&gt;

&lt;h1 id=&quot;3-내부-ip-주소-확인&quot;&gt;3. 내부 IP 주소 확인&lt;/h1&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ifconfig
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;를 통해 현재 서버 컴퓨터에 할당된 IP 주소를 알 수 있다.&lt;br /&gt;
output:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker0: flags=4099&amp;lt;UP,BROADCAST,MULTICAST&amp;gt;  mtu 1500
        inet 123.456.7.890  netmask 123.456.7.890  broadcast 123.456.7.890
        ether 02:42:82:b5:22:84  txqueuelen 0  (Ethernet)
        RX packets 0  bytes 0 (0.0 B)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 0  bytes 0 (0.0 B)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

enp0s31f6: flags=4163&amp;lt;UP,BROADCAST,RUNNING,MULTICAST&amp;gt;  mtu 1500
        inet 192.268.1.123  netmask 123.456.7.890  broadcast 123.456.7.890
        inet6 fe80::4f6c:76d6:b51f:aed9  prefixlen 64  scopeid 0x20&amp;lt;link&amp;gt;
        ether 70:85:c2:69:98:df  txqueuelen 1000  (Ethernet)
        RX packets 264847  bytes 25393804 (25.3 MB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 2474  bytes 257398 (257.3 KB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
        device interrupt 16  memory 0xdf100000-df120000  

lo: flags=73&amp;lt;UP,LOOPBACK,RUNNING&amp;gt;  mtu 65536
        inet 127.0.0.1  netmask 255.0.0.0
        inet6 ::1  prefixlen 128  scopeid 0x10&amp;lt;host&amp;gt;
        loop  txqueuelen 1000  (Local Loopback)
        RX packets 530  bytes 48618 (48.6 KB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 530  bytes 48618 (48.6 KB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;docker0는 무시하고 enp0s31f6:에 inet 다음에 있는 것이 내부 IP 주소다.&lt;/p&gt;

&lt;h1 id=&quot;4-ssh-서버-접속하기&quot;&gt;4. ssh 서버 접속하기&lt;/h1&gt;

&lt;p&gt;준비가 끝났다. 이제 접속하자. 로컬에서&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ssh [username]@[Hostname]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;와 같이 접속하면 된다&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ssh han@192.268.1.123
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;output:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;The authenticity of host '192.268.1.123 (192.268.1.123)' can't be established.
ECDSA key fingerprint is --------------------------.
Are you sure you want to continue connecting (yes/no)? yes
Warning: Permanently added '192.268.1.123' (ECDSA) to the list of known hosts.
han@192.268.1.123's password: 
Welcome to Ubuntu 18.04.3 LTS (GNU/Linux 5.0.0-32-generic x86_64)

 * Documentation:  https://help.ubuntu.com
 * Management:     https://landscape.canonical.com
 * Support:        https://ubuntu.com/advantage

 * Kata Containers are now fully integrated in Charmed Kubernetes 1.16!
   Yes, charms take the Krazy out of K8s Kata Kluster Konstruction.

     https://ubuntu.com/kubernetes/docs/release-notes

 * Canonical Livepatch is available for installation.
   - Reduce system reboots and improve kernel security. Activate at:
     https://ubuntu.com/livepatch

패키지 0개를  업데이트할 수 있습니다.
0 업데이트는 보안 업데이트입니다.

Your Hardware Enablement Stack (HWE) is supported until April 2023.

The programs included with the Ubuntu system are free software;
the exact distribution terms for each program are described in the
individual files in /usr/share/doc/*/copyright.

Ubuntu comes with ABSOLUTELY NO WARRANTY, to the extent permitted by
applicable law.

han@han-desktop:~$ 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;접속에 성공했다.&lt;/p&gt;

&lt;h1 id=&quot;5-끝내기&quot;&gt;5. 끝내기&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;exit
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;output:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;로그아웃
Connection to 192.268.1.123 closed.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;6-추가&quot;&gt;6. 추가&lt;/h1&gt;

&lt;p&gt;기본 포트 22번을 이용하면 보안에 취약하다고들 한다.
그래서 22를 자신만의 특별한 숫자로 바꾸는 것도 추천한다.
또한 openssh의 기본 설정으로 비밀번호와 함께 root 권한으로 접속할 수 있다.
하지만 단순하게 프로그램을 돌릴 계획인데 root 권한은 필요 없을 뿐더러 보안에 악영향을 끼칠 수 있으므로 금지시키는 것도 좋다.
public key?라 해서 파일형태로 key를 가지고 접속하는 방법도 있다.&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;출처:&lt;br /&gt;
&lt;a href=&quot;https://jimnong.tistory.com/713&quot;&gt;https://jimnong.tistory.com/713&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://cupjoo.tistory.com/98&quot;&gt;https://cupjoo.tistory.com/98&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://blog.naver.com/PostView.nhn?blogId=ares157&amp;amp;logNo=220984809651&quot;&gt;http://blog.naver.com/PostView.nhn?blogId=ares157&amp;amp;logNo=220984809651&lt;/a&gt;&lt;/p&gt;</content><author><name>HanSeokhyeon</name></author><category term="blog" /><summary type="html">연구실 서버 컴퓨터에서 docker를 이용해야 할 상황이 생겼다. 그래서 ssh를 이용해 로컬에서 서버로 접속해 docker를 사용하기 위해 ssh 서버 사용하는 법을 공부했고 정리한다.</summary></entry></feed>